
1.1	Task: Find something you’ve previously made in Processing using separate x and y variables and use PVectors instead.
1.1.2 Code (with x and y):
float x = 100; 
float y = 100; 
float xSpeed = 2.5;
float ySpeed = 2.2;
float angle = 0;
float maxSpeed = 20.0;


void draw() {
  background(255);
  
  x += xSpeed;
  y += ySpeed;

  if (x - 25 < 0 || x + 25 > width) {
    xSpeed *= -1;
    accelerate();
  }
  if (y - 25 < 0 || y + 25 > height) {
    ySpeed *= -1;
    accelerate();
  }

  angle += 0.05;

  translate(x, y);
  rotate(angle);
  drawCube();
}

void accelerate() {
  xSpeed *= 1.5;
  ySpeed *= 1.5;

  float speed = dist(0, 0, xSpeed, ySpeed);
  if (speed > maxSpeed) {
    float factor = maxSpeed / speed;
    xSpeed *= factor;
    ySpeed *= factor;
  }
}

void drawCube() {
  float len = 50;
  strokeWeight(3);
  stroke(0);
  fill(#be4147);

  // Front face
  beginShape();
  vertex(-len/2, -len/2, len/2);
  vertex(len/2, -len/2, len/2);
  vertex(len/2, len/2, len/2);
  vertex(-len/2, len/2, len/2);
  endShape(CLOSE);

  // Back face
  beginShape();
  vertex(-len/2, -len/2, -len/2);
  vertex(len/2, -len/2, -len/2);
  vertex(len/2, len/2, -len/2);
  vertex(-len/2, len/2, -len/2);
  endShape(CLOSE);

  // Connect front and back faces
  beginShape();
  vertex(-len/2, -len/2, len/2);
  vertex(-len/2, -len/2, -len/2);
  vertex(-len/2, len/2, -len/2);
  vertex(-len/2, len/2, len/2);
  endShape(CLOSE);

  beginShape();
  vertex(len/2, -len/2, len/2);
  vertex(len/2, -len/2, -len/2);
  vertex(len/2, len/2, -len/2);
  vertex(len/2, len/2, len/2);
  endShape(CLOSE);
}
1.1.2 Code (with PVector):
PVector position;
PVector velocity; 
float maxSpeed = 60.0;

void setup() {
  size(800, 600, P3D);
  position = new PVector(100, 100);
  velocity = new PVector(2.5, 2.2);
}

void draw() {
  background(255);
  
  position.add(velocity);

  if (position.x - 25 < 0 || position.x + 25 > width) {
    velocity.x *= -1;
    accelerate();
  }
  if (position.y - 25 < 0 || position.y + 25 > height) {
    velocity.y *= -1;
    accelerate();
  }

  float angle = millis() / 1000.0;

  translate(position.x, position.y);
  rotate(angle);
  drawCube();
}

void accelerate() {
  velocity.mult(1.5);

  float speed = velocity.mag();
  if (speed > maxSpeed) {
    velocity.normalize();
    velocity.mult(maxSpeed);
  }
}

void drawCube() {
  float len = 50;
  strokeWeight(3);
  stroke(0);
  fill(#be4147);

  // Front face
  beginShape();
  vertex(-len/2, -len/2, len/2);
  vertex(len/2, -len/2, len/2);
  vertex(len/2, len/2, len/2);
  vertex(-len/2, len/2, len/2);
  endShape(CLOSE);

  // Back face
  beginShape();
  vertex(-len/2, -len/2, -len/2);
  vertex(len/2, -len/2, -len/2);
  vertex(len/2, len/2, -len/2);
  vertex(-len/2, len/2, -len/2);
  endShape(CLOSE);

  // Connect front and back faces
  beginShape();
  vertex(-len/2, -len/2, len/2);
  vertex(-len/2, -len/2, -len/2);
  vertex(-len/2, len/2, -len/2);
  vertex(-len/2, len/2, len/2);
  endShape(CLOSE);

  beginShape();
  vertex(len/2, -len/2, len/2);
  vertex(len/2, -len/2, -len/2);
  vertex(len/2, len/2, -len/2);
  vertex(len/2, len/2, len/2);
  endShape(CLOSE);
}
1.1.3 The result is a cube that hits the border of the screen and keeps accelerating.

  
Fig 1.1.1 A cube accelerating each time it hits the border of the screen.


1.2	Task: Take one of the walker examples from the introduction and convert it to use PVectors.
1.2.2 Code (x and y):
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;

void setup() {
  size(640,360);
  background(255);
}

void draw() {
  background(255);

  x = x + xspeed;
  y = y + yspeed;
  if ((x > width) || (x < 0)) {
    xspeed = xspeed * -1;
  }
  if ((y > height) || (y < 0)) {
    yspeed = yspeed * -1;
  }
  stroke(0);
  fill(175);
  ellipse(x,y,16,16);
}
1.2.2 Code (PVector):
PVector location;
PVector velocity;

void setup() {
  size(640, 360);
  background(255);
  location = new PVector(100, 100);
  velocity = new PVector(1, 3.3);
}

void draw() {
  background(255);

  location.add(velocity);

  if ((location.x > width) || (location.x < 0)) {
    velocity.x = velocity.x * -1;
  }
  if ((location.y > height) || (location.y < 0)) {
    velocity.y = velocity.y * -1;
  }

  stroke(0);
  fill(175);
  ellipse(location.x, location.y, 16, 16);
}



1.2.3 The result is 
  
Fig 1.2 Bouncing ball from the examples.

1.3	Task: Extend the bouncing ball with vectors example into 3D. Can you get a sphere to bounce around a box?
1.3.2 Code:
PVector position;
PVector velocity; 
float radius = 20; 
float boxSize = 300; 
float damping = 0.7;
float rotationAngle = 0.2; 

void setup() {
  size(800, 600, P3D);
  position = new PVector(width / 2, height / 2, 0); // Start in the center of the screen
  velocity = new PVector(random(-10, 10), random(-10, 10), random(-10, 10));
}

void draw() {
  background(#C1653E);
  lights();
  translate(width / 2, height / 2);
  rotationAngle+=0.002;
  // Apply rotation to the box
  rotateX(rotationAngle);
  rotateY(rotationAngle);

  // Update position based on velocity
  position.add(velocity);

  // Check for collisions with the walls of the box
  if (position.x + radius > boxSize / 2) {
    position.x = boxSize / 2 - radius;
    velocity.x *= -damping;
  } else if (position.x - radius < -boxSize / 2) {
    position.x = -boxSize / 2 + radius; 
    velocity.x *= -damping;
  }
  if (position.y + radius > boxSize / 2) {
    position.y = boxSize / 2 - radius;
    velocity.y *= -damping; 
  } else if (position.y - radius < -boxSize / 2) {
    position.y = -boxSize / 2 + radius; 
    velocity.y *= -damping; 
  }
  if (position.z + radius > boxSize / 2) {
    position.z = boxSize / 2 - radius;
    velocity.z *= -damping; 
  } else if (position.z - radius < -boxSize / 2) {
    position.z = -boxSize / 2 + radius;
    velocity.z *= -damping; 
  }

  // Draw the box
  strokeWeight(8);
  stroke(#653EC1);
  noFill();
  box(boxSize);

  // Draw the bouncing sphere
  strokeWeight(1);
  stroke(#3EC165);
  fill(0);
  pushMatrix();
  translate(position.x, position.y, position.z);
  sphere(radius);
  popMatrix();
}

1.3.3 The result is a rotating box in 3D inside of which there is a ball that constantly bounces off the boxes walls.
  
Fig 1.3.3 Bouncing ball off the walls of a rotating box




1.4	Task: Write the limit() function for the PVector class.
  void limit(float max) {
    if (_______ > _______) {
      _________();
      ____(max);
    }
  }
1.4.2 Code:
void limit(float max) {
  if (velocity.mag() > max) {
    velocity.normalize();
    velocity.mult(max);
  }
}

1.5	Task: Create a simulation of a car (or runner) that accelerates when you press the up key and brakes when you press the down key.
1.5.2 Code:
float carWidth = 300;
float carHeight = 110;
float maxSpeed = 1200.0;
float friction = 0.1;
float respawnOffset = 500;
float decelerationFactor = 0.01;

Car myCar1;
Car myCar2;
Car myCar3;
Car myCar4;

void setup() {
  size(1600, 800);
  myCar1 = new Car(color(#AC2221), carWidth+40, height - carHeight + 50, 7);
  myCar2 = new Car(color(#2221AC), carWidth+650, height - carHeight - 150, 5);
  myCar3 = new Car(color(#E4811B), carWidth-205, height - carHeight - 325, 8);
  myCar4 = new Car(color(#6C9385), carWidth+350, height - carHeight - 530, 12);
}

void draw() {
  background(29, 43, 20);
  
  // road marks 
  stroke(255);
  fill(255);
  for (int i = 20; i <= 1800; i = i+160) {
    rect(i, 200, 170, 15);
  }
  for (int i = 20; i <= 1800; i = i+160) {
    rect(i, 405, 90, 15);
  }
  for (int i = 20; i <= 1800; i = i+160) {
    rect(i, 580, 170, 15);
  }
  // Update car positions based on their respective speeds
  myCar1.update();
  myCar2.update();
  myCar3.update();
  myCar4.update();
  
  // Respawn each car if it passes the right screen border
  respawnCar(myCar1);
  respawnCar(myCar2);
  respawnCar(myCar3);
  respawnCar(myCar4);
  
  // Draw the cars
  myCar1.display();
  myCar2.display();
  myCar3.display();
  myCar4.display();
}

void keyPressed() {
  if (keyCode == UP) {
    myCar1.accelerate();
    myCar2.accelerate();
    myCar3.accelerate();
    myCar4.accelerate();
  } else if (keyCode == DOWN) {
    myCar1.decelerate();
    myCar2.decelerate();
    myCar3.decelerate();
    myCar4.decelerate();
  }
}

void keyReleased() {
  if (keyCode == UP || keyCode == DOWN) {
    // Stop acceleration or deceleration when no keys are pressed
    myCar1.smoothDecelerate();
    myCar2.smoothDecelerate();
    myCar3.smoothDecelerate();
    myCar4.smoothDecelerate();
  }
}

class Car {
  color c;
  float xpos;
  float ypos;
  float acceleration;
  float carSpeed = 0;
  float smoothDeceleration = 0;

  Car(color tempC, float tempXpos, float tempYpos, float tempAcceleration) {
    c = tempC;
    xpos = tempXpos;
    ypos = tempYpos;
    acceleration = tempAcceleration;
  }

  void accelerate() {
    carSpeed += acceleration;
  }

  void decelerate() {
    carSpeed -= acceleration;
  }

  void smoothDecelerate() {
    // Gradually reduce acceleration for smoother deceleration
    if (carSpeed > 0) {
      smoothDeceleration = -decelerationFactor;
    } else if (carSpeed < 0) {
      smoothDeceleration = decelerationFactor;
    }
  }

  void update() {
    // Apply friction
    carSpeed -= carSpeed * friction;
    
    // Update car's position based on speed
    xpos += carSpeed;
    
    // Limit car's speed
    carSpeed = constrain(carSpeed, -maxSpeed, maxSpeed);
  }

  void display() {
    stroke(0);
    fill(c);
  beginShape();
    vertex(xpos, ypos);
    vertex(xpos+300, ypos);
    vertex(xpos+300, ypos-60);
    vertex(xpos+240, ypos-60);
    vertex(xpos+200, ypos-110);
    vertex(xpos+80, ypos-110);
    vertex(xpos+40, ypos-60);
    vertex(xpos, ypos-60);
    vertex(xpos, ypos);
  endShape();
  stroke(0);
  strokeWeight(1);
  fill(89, 89, 89);
  beginShape();
    vertex(xpos+62,ypos-68);
    vertex(xpos+130, ypos-68);
    vertex(xpos+130, ypos-100);
    vertex(xpos+85, ypos-100);
    vertex(xpos+62, ypos-68);
  endShape();
  beginShape();
    vertex(xpos+160,ypos-68);
    vertex(xpos+220, ypos-68);
    vertex(xpos+200, ypos-100);
    vertex(xpos+160, ypos-100);
    vertex(xpos+160, ypos-68);
  endShape();
    stroke(0);
    strokeWeight(3);
    noFill();
    line(xpos, ypos-60, xpos+240, ypos-60);
    rect(xpos+140, ypos-110,10,50);
    line(xpos+145, ypos-60, xpos+145, ypos);
    line(xpos+110, ypos-50, xpos+130, ypos-50);
    line(xpos+160, ypos-50, xpos+180, ypos-50);
    fill(65);
    circle(xpos+65,ypos,65);
    circle(xpos+235,ypos,65);
    fill(31, 22, 6);
    circle(xpos+65,ypos,40);
    circle(xpos+235,ypos,40);
  }
}

void respawnCar(Car car) {
  if (car.xpos > width + respawnOffset) {
    car.xpos = -1 * respawnOffset;
  }
}





1.5.3 The result is a drawing of a highway which contains multiple cars which will go forward and backwards.
 
Fig 1.5.3 Highway with cars.

1.6	Task: Referring to the Introduction, implement acceleration according to Perlin noise.
1.6.2 Code:
float xoff = 0;  // Initial value for Perlin noise
float yoff = 0;
float angle = 0.0;
float angleVel = 0.05;
float radius = 350;

void setup() {
  size(800, 800);
}

void draw() {
  background(#69004C);
  
  // Generate Perlin noise for smooth movement
  float xNoiseValue = noise(xoff) * width;
  float yNoiseValue = noise(yoff) * height;
  
  // Calculate position using Perlin noise
  float x = width / 2 + cos(angle) * radius;
  float y = height / 2 + sin(angle) * radius;
  
  // Constrain the coordinates to stay within the screen borders
  float constrainedX = constrain(xNoiseValue, 0, width);
  float constrainedY = constrain(yNoiseValue, 0, height);
  
  // Vary the diameter of the outer circle based on Perlin noise
  float diameterNoise = noise(angle); 
  float variousDiameter = map(diameterNoise, 0, 1, 200, 380);
  
  // Draw ellipses in different quadrants
  float diameter = 50;
  
  noStroke();
  fill(255);
  ellipse(width/2, height/2, variousDiameter, variousDiameter);
  fill(#D7283B);
  ellipse(constrainedX, constrainedY, diameter, diameter);
  fill(#92D728);
  ellipse(width - constrainedX, constrainedY, diameter, diameter);
  fill(#28D7C4);
  ellipse(constrainedX, height - constrainedY, diameter, diameter);
  fill(#6D28D7);
  ellipse(width - constrainedX, height - constrainedY, diameter, diameter);
  fill(#E2D71D);
  ellipse(constrainedX, width/2, diameter, diameter);
  fill(#1DE274);
  ellipse(height/2, constrainedY, diameter, diameter);
  fill(#1D28E2);
  ellipse(width - constrainedX, width/2, diameter, diameter);
  fill(#E21D8B);
  ellipse(height/2, height - constrainedY, diameter, diameter);
  fill(0);
  strokeWeight(2);
  stroke(#BBE817);
  ellipse(x, y, diameter*1.5, diameter*1.5);
  fill(0);
  stroke(#17E8AD);
  ellipse(width - x, height - y, diameter*1.5, diameter*1.5);
  fill(0);
  stroke(#4417E8);
  ellipse(x, height - y, diameter*1.5, diameter*1.5);
  fill(0);
  stroke(#E81752);
  ellipse(width - x, y, diameter*1.5, diameter*1.5);
  
  // Increment the Perlin noise parameters for the next frame
  xoff += 0.01;
  yoff += 0.01;
  
  // Update angle based on Perlin noise
  angle += angleVel;
}
1.6.3 The result is a drawing of multiple circles which are moving using perlin noise.
  
Fig 1.6.3 Drawing of perlin noise circles.

1.7	Task: Translate the following pseudocode to code using static or non-static functions where appropriate.
•	The PVector v equals (1,5).
•	The PVector u equals v multiplied by 2.
•	The PVector w equals v minus u.
•	Divide the PVector w by 3.
PVector v = new PVector(1,5);
PVector u = ________._____(__,__);
PVector w = ________._____(__,__);
___________;
1.7.2 Code:
PVector v = new PVector(1, 5);
PVector u = PVector.mult(v, 2);
PVector w = PVector.sub(v, u);
w.div(3);

1.8	Task: Try implementing the above example with a variable magnitude of acceleration, stronger when it is either closer or farther away.
1.8.2 Code (normal):
Mover[] movers = new Mover[20];

void setup() {
  size(640,360);
  background(255);
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover();
  }
}

void draw() {
  background(255);

  for (int i = 0; i < movers.length; i++) {
    movers[i].update();
    movers[i].checkEdges();
    movers[i].display();
  }
}

class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  float topspeed;

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    topspeed = 4;
  }

  void update() {

    PVector mouse = new PVector(mouseX,mouseY);
    PVector dir = PVector.sub(mouse,location);
    dir.normalize();
    dir.mult(0.5);
    acceleration = dir;

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  void checkEdges() {

    if (location.x > width) {
      location.x = 0;
    } else if (location.x < 0) {
      location.x = width;
    }

    if (location.y > height) {
      location.y = 0;
    }  else if (location.y < 0) {
      location.y = height;
    }
  }
}
1.8.2 Code (speed dependent of distance):
Mover[] movers = new Mover[20];

void setup() {
  size(640,360);
  background(255);
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover();
  }
}

void draw() {
  background(255);

  for (int i = 0; i < movers.length; i++) {
    movers[i].update();
    movers[i].checkEdges();
    movers[i].display();
  }
}

class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration;
  float topspeed;

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    topspeed = 4;
  }

  void update() {
    PVector mouse = new PVector(mouseX, mouseY);

    PVector dir = PVector.sub(mouse, location);

    float distance = dir.mag();

    dir.normalize();

    float magnitude = map(distance, 0, width, 0.5, 0.01); 
    dir.mult(magnitude);

    acceleration = dir;

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
}



  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  void checkEdges() {

    if (location.x > width) {
      location.x = 0;
    } else if (location.x < 0) {
      location.x = width;
    }

    if (location.y > height) {
      location.y = 0;
    }  else if (location.y < 0) {
      location.y = height;
    }
  }
}
1.8.3 The result is a drawing of circles which will move towards the mouse:
  
Fig 1.8.3 Circles moving towards the mouse.

Task 4 part 2 (after the midterm)
1.1	The task:
A: Do the sketch using the function: 
• randomGaussian() 
• randomSeed() 
• random() 
• noiseDetail() 
• noiseSeed() 
• noise() 
• map() 
B: Vectors project: Develop a set of rules for simulating the real-world behavior of a creature, such as a nervous fly, swimming fish, hopping bunny, slithering snake, etc. Can you control the object’s motion by only manipulating the acceleration? Try to give the creature a personality through its behavior (rather than through its visual design).
1.2	The code: I have decided to create a scene of a fish tank where a lot of fish swim freely. The user can spawn food by clicking on the screen (for each click, one fish food will be spawned on the position of the click,) or  by pressing (holding) the “s” key on the keyboard (a lot of fish food will spawn in random locations on the screen.) The fish will move freely until fish food is spawned. Once there is any food on the screen, all the fish will go towards it and try to eat it first.
ArrayList<Fish> fishes = new ArrayList<Fish>();
ArrayList<PVector> foodPositions = new ArrayList<PVector>();
float minSeparation = 10; 
int numEdges = 100;
PImage sea;
PShape screen;

void preload() {
  sea = loadImage("sea.jpg");
}

void setup() {
  fullScreen();
  sea = loadImage("sea.jpg");
  screen = createShape(RECT, 0, 0, 5464, 3070);
  screen.setTexture(sea);
  for (int i = 0; i < 40; i++) {
    Fish fish = new Fish(random(width), random(height));
    fishes.add(fish);
  }
}

void draw() {
  background(#274F8B);
  shape(screen);
  for (Fish fish : fishes) {
    fish.avoidCollision(fishes); 
    
    if (foodPositions.size() > 0) {
      PVector closestFood = fish.findClosestFood();
      if (closestFood != null) {
        fish.moveTowards(closestFood);
        if (fish.position.dist(closestFood) < 80) {
          foodPositions.remove(closestFood);
        }
      }
    } else {
      fish.moveRandomly();
    }
    
    fish.update();
    fish.display();
    fish.wrapAroundEdges();
  }
  
  for (PVector food : foodPositions) {
    fill(139, 69, 19);
    ellipse(food.x, food.y, 20, 20);
  }
  noStroke();
  fill(#536c57,100);
  rect(0,0,4000,3000);
}

void mousePressed() {
  foodPositions.add(new PVector(mouseX, mouseY));
}

void keyPressed() {
  if (key == 's' || key == 'S') {
    foodPositions.add(new PVector(random(width), random(height)));
  }
}

class Fish {
  PVector position;
  PVector velocity;
  PVector acceleration;
  float maxSpeed;
  float maxForce;
  PVector prevAcceleration;  // Store previous acceleration for damping

  Fish(float startX, float startY) {
    position = new PVector(startX, startY);
    velocity = PVector.random2D();
    acceleration = new PVector(0, 0);
    prevAcceleration = acceleration.copy();  // Initialize prevAcceleration
    maxSpeed = 5; 
    maxForce = 0.5;
  }

  void applyForce(PVector force) {
    acceleration.add(force);
  }

  void moveRandomly() {
    PVector randomDirection = PVector.random2D();
    randomDirection.mult(0.1);
    applyForce(randomDirection);
  }

  void moveTowards(PVector target) {
    PVector desired = PVector.sub(target, position);
    desired.normalize();
    desired.mult(maxSpeed);

    PVector steer = PVector.sub(desired, velocity);
    steer.limit(maxForce);
    applyForce(steer);
  }

  PVector findClosestFood() {
    float closestDist = Float.MAX_VALUE;
    PVector closestFood = null;

    for (PVector food : foodPositions) {
      float distance = position.dist(food);
      if (distance < closestDist) {
        closestDist = distance;
        closestFood = food;
      }
    }

    return closestFood;
  }

  void avoidCollision(ArrayList<Fish> otherFishes) {
    for (Fish otherFish : otherFishes) {
      if (otherFish != this) {
        float distance = position.dist(otherFish.position);
        if (distance < minSeparation) {
          PVector avoidVector = PVector.sub(position, otherFish.position);
          avoidVector.normalize();
          avoidVector.mult(maxForce);
          applyForce(avoidVector);
        }
      }
    }
  }
  
  void update() {
    // Apply damping to the acceleration
    PVector damping = PVector.sub(acceleration, prevAcceleration);
    damping.mult(0.1);  // Damping factor
    acceleration.sub(damping);

    velocity.add(acceleration);
    velocity.limit(maxSpeed);
    position.add(velocity);
    prevAcceleration = acceleration.copy();  // Update prevAcceleration
    acceleration.mult(0);
  }

  void display() {
  float theta = velocity.heading() + PI / 2;
  strokeWeight(2);
  stroke(#DC5000);

  pushMatrix();
  translate(position.x, position.y);
  rotate(theta);
  
  fill(#BCEFF4,127);
  strokeWeight(0);
  // Left fin
  beginShape();
  vertex(-18, -35);
  quadraticVertex(-53, 5, -18, -5);
  endShape();

  // Right fin
  beginShape();
  vertex(18, -35);
  quadraticVertex(53, 5, 18, -5);
  endShape();
  
  // Body
  strokeWeight(2);
  stroke(#DC5000);
  fill(#FF6F1D,255);
  noStroke();
  ellipse(0, 0, 40, 150);

  // Eyes
  stroke(0);
  strokeWeight(2);
  line(-6, -60, -7, -55);
  line(8, -60, 9, -55);

  // Tail
  strokeWeight(0);
  fill(#BCEFF4,127);
  strokeWeight(0);
  beginShape();
  vertex(-5, 72);
  quadraticVertex(-30, 102, 0, 102);
  quadraticVertex(30, 102, 5, 72);
  endShape();

  popMatrix();
}

  
  void wrapAroundEdges() {
    if (position.x > width+100) {
      position.x = -100;
    } else if (position.x < -100) {
      position.x = width+100;
    }

    if (position.y > height+100) {
      position.y = -100;
    } else if (position.y < -100) {
      position.y = height+100;
    }
  }
}
1.3	The drawings:
 
Figure 1 Fish swimming freely
 
Figure 2 Fish going towards food

2.1 In this laboratory work, we explored two exciting tasks. In Task A, we used various functions like randomGaussian(), randomSeed(), random(), noiseDetail(), noiseSeed(), noise(), and map() to create a sketch that displayed random ellipses on the screen, adding an element of unpredictability and randomness to the visual output.In Task B, we delved into creating a simulated creature with its unique behavior, like that of a nervous fly, swimming fish, hopping bunny, or slithering snake. By manipulating acceleration, we controlled the motion of the creature, aiming to give it a distinct personality through its behavior rather than its appearance. This task allowed us to explore the fascinating world of simulating real-world behavior in a creative and interactive way.Through these tasks, we gained valuable insights into utilizing functions and vectors to generate dynamic and engaging visual displays, setting the foundation for more advanced explorations in the realm of creative coding and simulations.

[1] Processing – random function. https://processing.org/reference/random_.html 
[2] Processing – noise detail function. https://processing.org/reference/noiseDetail_.html 
[3] Processing – noise function. https://processing.org/reference/noise_.html 
[4] Processing – mapping function. https://processing.org/reference/map_.html 
[5] The coding train – the nature of code: https://www.youtube.com/playlist?list=PLRqwX-V7Uu6YVljJvFRCyRM6mmF5wMPe 
[6] “The nature of coding” book, by Daniel Shiffman - https://natureofcode.com/book/introduction/ 
[7] The coding train – Vectors: https://www.youtube.com/playlist?list=PLRqwX-V7Uu6ZwSmtE13iJBcoI-r4y7iEc 

