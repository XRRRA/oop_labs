1.1 The purpose of Task 1 was to create a 400x400 sketch with a specified background color using the setup() and draw() functions. Within the setup() function, the task involves drawing a rectangle with a line inside it, centered within the sketch, adjusting coordinates, and changing line thickness and color. In the draw() function, the task includes drawing specific shapes (arc, chord, and pie) within the rectangle, each with defined angle conditions and color changes, while also adjusting the position of the pie.
 
2.1 The conditions are: 
rx=180 ry=150 (is a half of the width and a half of the height) - iPut next code in a function draw() - The thickness of the line is 4. Change the color for each shape. 
•	Draw an arc inside the rectangle in quadrant I 
•	Draw a chord inside the rectangle. - angle to start the chord is in middle of quadrant II - angle to end the chord is the end of quadrant III 
•	Draw a Pie inside the rectangle. - angle to start the pie is the end of quadrant IV - angle to end the pie is the middle of quadrant II 
Change the RX for 5 points in pie function (rx-5; ry-5) 

3.1 The program code: 
void setup() {
  size(400, 400);
  background(254,255,206);
  noStroke();
  fill(0,255,85);
}

void draw() {
  // Varianta 2
  // Iordan Liviu
  int rx=180, ry=150;
  stroke(0);
  strokeWeight(2);
  noFill();
  rect(20,50,2*rx,2*ry);
  line(20, 50, 2*rx+20, 2*ry+50);
  line(20, 2*ry+50, 2*rx+20, 50);
  line(rx+20, 50, rx+20, 2*ry+50);
  line(20, rx+20, 2*ry+80, rx+20);
  strokeWeight(4);
  size(400,400);
  // Ex 1 B: Arc in 1st quadrant
  stroke(77, 204, 45);
  arc(200, 200, 2*rx, 2*ry, PI/-2, 0);
  // Ex 1 C: Chord from middle of quadrant 2 to the end of quadrant 3
  stroke(76, 36, 179);
  arc(200, 200, 2*rx, 2*ry, PI/2, PI+PI/4, CHORD);
  // Ex 2 C: Pie from the end of quadrant 4 to the middle of quadrant 2
  stroke(140, 15, 92);
  arc(200, 200, 2*(rx-5), 2*(ry-5), -1*(PI-PI/4), 0, PIE);
}
 







4.1 Screen printing of program execution: 
 
 
Figure1. Sketch

5.1 In conclusion, during the realization of the class work, I have learned how to work with arcs, chords, and pies of a circle. I have learned how to work with the coordinates and how the coordinates are working in processing,

1.2 The purpose of Task 2 is to utilize 2D primitive functions to create an interactive sketch that incorporates movement through the use of variables, conditionals, loops, and custom functions, allowing learners to apply fundamental programming concepts in a creative coding context.

2.2 The conditions are:
•	To make a sketch with 2d primitives function and move it;
•	To use random function or increase the coordinate of the sketch combination;
•	To use VARIABLES, CONDITIONALS, LOOPS function and create our own function and call it in Draw function.

3.2 The program code (quick note: in order for my code to work, the images provided together with the code should also be placed in the same folder as the script.): 
PImage logo, star, KFC_Logo;
Car myCar1;
Car myCar2;
Car myCar3;
Car myCar4;

void setup() {
  size(1400, 1200);
  background(53, 64, 99);
  noStroke();
  fill(0,255,85);
  logo = loadImage("kfc.png");
  star = loadImage("star.png");
  KFC_Logo = loadImage("KFC_Logo.png");
  myCar1 = new Car(color(148, 0, 0), -500, 850, 30); 
  myCar2 = new Car(color(14, 0, 171), 0, 850, 30); 
  myCar3 = new Car(color(9, 173, 132), 500, 850, 30); 
  myCar4 = new Car(color(173, 69, 9), 1000, 850, 30);
}

void draw() {
  color wall = color(146,142,136,255), wall_deco = color(148,144,138,255), wall_stroke = color(123,111,99,255), red_line = color(94,21,23,255), black_base = color(19,17,16,255);
  // Moon and Sun
  float rg = map(abs((millis()%1000)-500), 0, 500, 0, 255);
  background(rg, rg, 0);
  pushMatrix();
  translate(width/2, height/2);
  rotate(-PI);
  rotate(map(millis()%10000, 0, 1000, 0, TWO_PI));
  // The Sun
  fill(255, 255-rg, 255-rg); 
  circle(0, 550, 200);
  // The Moon
  fill(255);
  circle(0, -550, 200);
  popMatrix();
  // road
  noStroke();
  fill(29, 43, 20);
  rect(0,800,1400,400);
  strokeWeight(3);
  stroke(0);
  fill(56, 56, 56);
  rect(0,670,1400,400);
  // road marks 
  stroke(255);
  fill(255);
  for (int i = 20; i <= 1360; i = i+160) {
    rect(i, 860, 120, 30);
  }
  // red background wall
  stroke(red_line);
  strokeWeight(2);
  fill(151,21,26,255);
  rect(210, 330, 100, 315);
  // black base
  strokeWeight(1);
  stroke(97,95,90,255);
  fill(19,17,16,255);
  rect(210, 645, 100, 100);
  // wall detail 1 (bottom)
  fill(red_line);
  stroke(red_line);
  rect(205, 640, 110, 15);
  // Wall detail 2 (mid bot) 460
  fill(red_line);
  stroke(red_line);
  rect(205, 460, 110, 15);
  // Wall detail 3 (mid top) 370
  fill(red_line);
  stroke(red_line);
  rect(205, 370, 110, 25);
  // Wall detail 4 (top)
  fill(red_line);
  stroke(red_line);
  rect(205, 325, 110, 20);
  // Wall grid
  strokeWeight(1);
  for (int i = 210; i <= 310; i = i+20) {
  line(i, 380, i, 465);
  }
  line(210, 400 ,310, 400);
  line(210, 430 ,310, 430);
  
  // red background wall 2
  stroke(red_line);
  strokeWeight(2);
  fill(151,21,26,255);
  rect(1025, 330, 100, 315);
  // black base
  strokeWeight(1);
  stroke(97,95,90,255);
  fill(19,17,16,255);
  rect(1025, 645, 100, 100);
  // wall detail 1 (bottom)
  fill(red_line);
  stroke(red_line);
  rect(1020, 640, 110, 15);
  // Wall detail 2 (mid bot) 460
  fill(red_line);
  stroke(red_line);
  rect(1020, 460, 110, 15);
  // Wall detail 3 (mid top) 370
  fill(red_line);
  stroke(red_line);
  rect(1020, 370, 110, 25);
  // Wall detail 4 (top)
  fill(red_line);
  stroke(red_line);
  rect(1020, 325, 110, 20);
  // Wall grid
  strokeWeight(1);
  for (int i = 1025; i <= 1125; i = i+20) {
  line(i, 380, i, 465);
  }
  line(1025, 400 ,1125, 400);
  line(1025, 430 ,1125, 430);
  
  // White wall
  strokeWeight(2);
  noStroke();
  fill(wall);
  rect(270, 360, 830, 315);
  // black base
  strokeWeight(1);
  stroke(97,95,90,255);
  fill(19,17,16,255);
  rect(270, 680, 830, 85);
  // wall detail 1 (bottom)
  fill(wall_deco);
  stroke(wall_stroke);
  rect(265, 670, 840, 15);
  // Wall detail 2 (mid bot)
  fill(wall_deco);
  stroke(wall_stroke);
  rect(265, 500, 840, 15);
  // Wall detail 3 (mid top)
  fill(wall_deco);
  stroke(wall_stroke);
  rect(265, 410, 840, 25);
  // Wall detail 4 (top)
  fill(wall_deco);
  stroke(wall_stroke);
  rect(265, 350, 840, 20);
  // Wall grid
  strokeWeight(1);
  for (int i = 270; i <= 1100; i = i+20) {
  line(i, 435, i, 500);
  }
  line(270, 455 ,1098, 455);
  line(270, 475 ,1098, 475);
  // The roof
  fill(wall);
  stroke(wall_deco);
  strokeWeight(6);
  beginShape();
  vertex(370, 300);
  vertex(270, 300);
  vertex(220, 322);
  vertex(330, 322);
  vertex(275, 350);
  vertex(1095, 350);
  vertex(995, 322);
  vertex(1105, 322);
  vertex(1030, 300);
  vertex(930, 300);
  vertex(870, 290);
  vertex(410, 290);
  vertex(370, 300);
  endShape();
  // Roof part 2
  fill(52,51,47,255);
  noStroke();
  beginShape();
  vertex(370, 320);
  vertex(330, 322);
  vertex(295, 350);
  vertex(1075, 350);
  vertex(995, 322);
  vertex(930, 320);
  vertex(870, 310);
  vertex(410, 310);
  vertex(370, 320);
  endShape();
  
  //355-x1, 480-y1, 170-w, 240-h, 850-x2 480-y2, 95, 160 - cover, 122,166 - glass
  stroke(97,95,90,255);
  strokeWeight(1);
  fill(19,17,16,255);
  // windows frame
  rect(355, 480, 170, 240);
  rect(850, 480, 170, 240);
  // windows
  fill(209, 169, 50);
  noStroke();
  rect(360, 485, 160, 230);
  rect(855, 485, 160, 230);
  // covers
  strokeWeight(4);
  stroke(red_line);
  noFill();
  rect(360, 485, 160, 195);
  line(440, 485, 440, 680);
  rect(855, 485, 160, 195);
  line(935, 485, 935, 680);
  strokeWeight(3);
  for (int i = 484; i <= 680; i = i+5) {
  line(360, i, 520, i);
  line(855, i, 1015, i);
}
  // center logo piece
  stroke(red_line);
  strokeWeight(1);
  fill(red_line);
  rect(575, 330, 230, 434);
  // light above
  stroke(255);
  strokeWeight(1);
  fill(255);
  rect(575, 300, 230, 35);
  // main piece
  stroke(black_base);
  strokeWeight(1);
  fill(151,21,26,255);
  rect(600, 345, 180, 400);
  // logos work
  stroke(255);
  strokeWeight(1);
  fill(255);
  rect(636, 346, 36, 398);
  rect(708, 346, 36, 398);
  image(logo, 533, 370, 320, 240);
  image(star, 636, 610, 36, 36);
  image(star, 672, 600, 36, 36);
  image(star, 708, 610, 36, 36);
  image(KFC_Logo, 830, 380, 240, 75);
  
  // Cars
  myCar1.move();
  myCar1.display();
  myCar2.move();
  myCar2.display();
  myCar3.move();
  myCar3.display();
  myCar4.move();
  myCar4.display();
}

class Car { 
  color c;
  float xpos;
  float ypos;
  float xspeed;

  Car(color tempC, float tempXpos, float tempYpos, float tempXspeed) { 
    c = tempC;
    xpos = tempXpos;
    ypos = tempYpos;
    xspeed = tempXspeed;
  }

  void display() {
    stroke(0);
    fill(c);
  beginShape();
    vertex(xpos, ypos);
    vertex(xpos+300, ypos);
    vertex(xpos+300, ypos-60);
    vertex(xpos+240, ypos-60);
    vertex(xpos+200, ypos-110);
    vertex(xpos+80, ypos-110);
    vertex(xpos+40, ypos-60);
    vertex(xpos, ypos-60);
    vertex(xpos, ypos);
  endShape();
  stroke(0);
  strokeWeight(1);
  fill(89, 89, 89);
  beginShape();
    vertex(xpos+62,ypos-68);
    vertex(xpos+130, ypos-68);
    vertex(xpos+130, ypos-100);
    vertex(xpos+85, ypos-100);
    vertex(xpos+62, ypos-68);
  endShape();
  beginShape();
    vertex(xpos+160,ypos-68);
    vertex(xpos+220, ypos-68);
    vertex(xpos+200, ypos-100);
    vertex(xpos+160, ypos-100);
    vertex(xpos+160, ypos-68);
  endShape();
    stroke(0);
    strokeWeight(3);
    noFill();
    line(xpos, ypos-60, xpos+240, ypos-60);
    rect(xpos+140, ypos-110,10,50);
    line(xpos+145, ypos-60, xpos+145, ypos);
    line(xpos+110, ypos-50, xpos+130, ypos-50);
    line(xpos+160, ypos-50, xpos+180, ypos-50);
    fill(65);
    circle(xpos+65,ypos,65);
    circle(xpos+235,ypos,65);
    fill(31, 22, 6);
    circle(xpos+65,ypos,40);
    circle(xpos+235,ypos,40);
  }

  void move() {
    xpos = xpos + xspeed;
    if (xpos > width) {
      xpos = -500;
    }
  }
}
4.2 Screen printing of program execution: 
Figure2. Sketch
 
Figure2.1 Sketch

5.2 In conclusion, during the realization process of the second laboratory work, I have learned a lot of things about processing. My goal was to create a scene which will contain moving objects, and a moving sun and moon cycle, alongside a KFC restaurant. To begin with, I have learned how to work with images. How to implement images and how to manipulate their positions, dimensions, etc. For the “day-night” cycle, I have used a source from the internet, which has helped me to understand how to make 2 objects move on a circle path and how to make the color of the background wo change when those objects are moving [1]. I have learned how to work with functions like map, abs, millis, rotate, etc. For the restaurant, I have used loops and simple functions like lines, rectangles, and shape creation to build the restaurant. Considering the moving cars, I have created a car class which if we call by using object.display(), would return a model of a car which I have created using shape creation, and by using object.move(), it will move the object by incrementing its x coordinate (because the objects are moving only horizontally) so a simple animation would be shown. Also, I made the animation itself infinite by checking whether the x coordinate of the object will reach the width of the screen, it would nullify it, so the object would be created again at the left part of the screen. The loop which was used in an infinite loop. To learn about the class and how objects work, I have used the link provided by the teacher [2] and also the official references from the Processing website [3].

[1] https://forum.processing.org/two/discussion/4968/how-to-make-my-shape-move-on-a-curve.html
[2] http://learningprocessing.com/examples/chp08/example-08-02-twoobjects 
[3] https://processing.org/reference 
